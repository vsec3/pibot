# Economy Items: Golden Potato, Rainbow Trout, Bass, Sunfish, Spearfish, Voltfish, Angel_o8
import asyncio
import json
import random
from collections import defaultdict
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
import discord
from discord import app_commands
from discord.ext import commands

intents = discord.Intents.all()
bot = commands.Bot(command_prefix="!", intents=intents)

case_counter = 1
user_cases: Dict[int, List[dict]] = defaultdict(list)
user_warns: Dict[int, List[dict]] = defaultdict(list)
tempban_tasks: Dict[int, asyncio.Task] = {}
DATA_FILE = Path(__file__).with_name("moddata.json")
ECONOMY_FILE = Path(__file__).with_name("economy.json")
ITEM_DATA: Dict[str, Dict[str, Any]] = {
    "golden_potato": {"name": "Golden Potato", "min_value": 30, "max_value": 30, "sellable": True},
    "rainbow_trout": {"name": "Rainbow Trout", "min_value": 15, "max_value": 22, "sellable": True},
    "bass": {"name": "Bass", "min_value": 18, "max_value": 19, "sellable": True},
    "sunfish": {"name": "Sunfish", "min_value": 17, "max_value": 20, "sellable": True},
    "spearfish": {"name": "Spearfish", "min_value": 25, "max_value": 32, "sellable": True},
    "voltfish": {"name": "Voltfish", "min_value": 27, "max_value": 36, "sellable": True},
    "angel_o8": {"name": "Angel_o8", "min_value": 5000, "max_value": 10000, "sellable": True},
    "lockpick": {"name": "Lockpick", "price": 50, "sellable": False},
    "gun": {"name": "Gun", "price": 150, "sellable": False},
    "advanced_lockpick": {"name": "Advanced Lockpick", "price": 500, "sellable": False},
    "hacker_tool": {"name": "Hacker Tool", "price": 1200, "sellable": False},
    "mask": {"name": "Mask", "price": 60, "sellable": False},
    "license_plate_blocker": {"name": "License Plate Blocker", "price": 500, "sellable": False},
    "admin_itemitemitem": {"name": "Volts Prize", "price": 9999999, "sellable": False},
}
SHOP_ITEMS = ["lockpick", "gun", "advanced_lockpick", "hacker_tool", "mask", "license_plate_blocker"]
def currency(amount: int) -> str:
    return f"${amount:,}"
class EconomyManager:
    def __init__(self, file_path: Path):
        self.file_path = file_path
        self.lock = asyncio.Lock()
        self.users: Dict[str, Dict[str, object]] = {}
    def _ensure_user(self, user_id: int) -> Dict[str, object]:
        key = str(user_id)
        if key not in self.users:
            self.users[key] = {"wallet": 0, "bank": 0, "inventory": {}}
        return self.users[key]
    async def load(self) -> None:
        async with self.lock:
            if not self.file_path.exists():
                self.users = {}
                return
            try:
                with open(self.file_path, "r") as f:
                    data = json.load(f)
                raw_users = data.get("users", {})
                self.users = {}
                for user_id, payload in raw_users.items():
                    wallet = max(0, int(payload.get("wallet", 0)))
                    bank = max(0, int(payload.get("bank", 0)))
                    inventory_data = {}
                    raw_inventory = payload.get("inventory", {})
                    for item_key, amount in raw_inventory.items():
                        if item_key in ITEM_DATA:
                            inventory_data[item_key] = max(0, int(amount))
                    self.users[user_id] = {"wallet": wallet, "bank": bank, "inventory": inventory_data}
            except Exception:
                self.users = {}
    async def save(self) -> None:
        async with self.lock:
            data = {"users": self.users}
            with open(self.file_path, "w") as f:
                json.dump(data, f, indent=2)
    async def ensure_user(self, user_id: int) -> None:
        async with self.lock:
            self._ensure_user(user_id)
    async def get_balances(self, user_id: int) -> Tuple[int, int]:
        async with self.lock:
            user = self._ensure_user(user_id)
            return user["wallet"], user["bank"]
    async def total_balance(self, user_id: int) -> int:
        async with self.lock:
            user = self._ensure_user(user_id)
            return user["wallet"] + user["bank"]
    async def deposit(self, user_id: int, amount: Optional[int]) -> int:
        async with self.lock:
            user = self._ensure_user(user_id)
            if user["wallet"] <= 0:
                return 0
            if amount is None or amount > user["wallet"]:
                deposit_amount = user["wallet"]
            else:
                deposit_amount = amount
            if deposit_amount <= 0:
                return 0
            user["wallet"] -= deposit_amount
            user["bank"] += deposit_amount
            return deposit_amount
    async def withdraw(self, user_id: int, amount: Optional[int]) -> int:
        async with self.lock:
            user = self._ensure_user(user_id)
            if user["bank"] <= 0:
                return 0
            if amount is None or amount > user["bank"]:
                withdraw_amount = user["bank"]
            else:
                withdraw_amount = amount
            if withdraw_amount <= 0:
                return 0
            user["bank"] -= withdraw_amount
            user["wallet"] += withdraw_amount
            return withdraw_amount
    async def add_wallet(self, user_id: int, amount: int) -> int:
        async with self.lock:
            user = self._ensure_user(user_id)
            user["wallet"] += max(0, amount)
            return user["wallet"]
    async def add_bank(self, user_id: int, amount: int) -> int:
        async with self.lock:
            user = self._ensure_user(user_id)
            user["bank"] += max(0, amount)
            return user["bank"]
    async def deduct_wallet(self, user_id: int, amount: int) -> bool:
        async with self.lock:
            user = self._ensure_user(user_id)
            if amount <= 0 or user["wallet"] < amount:
                return False
            user["wallet"] -= amount
            return True
    async def has_wallet(self, user_id: int, amount: int) -> bool:
        async with self.lock:
            user = self._ensure_user(user_id)
            return user["wallet"] >= amount
    async def get_inventory(self, user_id: int) -> Dict[str, int]:
        async with self.lock:
            user = self._ensure_user(user_id)
            return dict(user["inventory"])
    async def add_item(self, user_id: int, item_key: str, amount: int = 1) -> None:
        async with self.lock:
            if item_key not in ITEM_DATA:
                return
            user = self._ensure_user(user_id)
            inventory = user["inventory"]
            inventory[item_key] = inventory.get(item_key, 0) + max(0, amount)
    async def sell_items(self, user_id: int, item_key: Optional[str], quantity: Optional[int]) -> Tuple[List[Tuple[str, int, int]], int]:
        async with self.lock:
            user = self._ensure_user(user_id)
            inventory = user["inventory"]
            if not inventory:
                return [], 0
            details: List[Tuple[str, int, int]] = []
            total_value = 0
            def sell_specific(key: str, qty: int) -> None:
                nonlocal total_value
                if key not in ITEM_DATA or qty <= 0:
                    return
                value_data = ITEM_DATA[key]
                if not value_data.get("sellable", True):
                    return
                sold_value = 0
                for _ in range(qty):
                    sold_value += random.randint(value_data["min_value"], value_data["max_value"])
                inventory[key] -= qty
                if inventory[key] <= 0:
                    inventory.pop(key, None)
                details.append((key, qty, sold_value))
                total_value += sold_value
            if item_key is None:
                for key, count in list(inventory.items()):
                    sell_specific(key, count)
            else:
                if item_key not in inventory or inventory[item_key] <= 0:
                    return [], 0
                available = inventory[item_key]
                sell_quantity = available if quantity is None else min(quantity, available)
                if sell_quantity <= 0:
                    return [], 0
                sell_specific(item_key, sell_quantity)
            if total_value > 0:
                user["wallet"] += total_value
            return details, total_value
    async def leaderboard(self, limit: int = 10) -> List[Tuple[int, int, int, int]]:
        async with self.lock:
            standings: List[Tuple[int, int, int, int]] = []
            for user_id, payload in self.users.items():
                wallet = payload.get("wallet", 0)
                bank = payload.get("bank", 0)
                total = wallet + bank
                standings.append((int(user_id), wallet, bank, total))
            standings.sort(key=lambda item: item[3], reverse=True)
            return standings[:limit]
    async def has_item(self, user_id: int, item_key: str) -> bool:
        async with self.lock:
            user = self._ensure_user(user_id)
            return user["inventory"].get(item_key, 0) > 0
    async def has_items(self, user_id: int, item_keys: List[str]) -> bool:
        async with self.lock:
            user = self._ensure_user(user_id)
            inventory = user["inventory"]
            return all(inventory.get(key, 0) > 0 for key in item_keys)
    async def seize_all_items(self, user_id: int) -> Dict[str, int]:
        async with self.lock:
            user = self._ensure_user(user_id)
            seized = dict(user["inventory"])
            user["inventory"] = {}
            return seized

economy_manager = EconomyManager(ECONOMY_FILE)
def resolve_item_key(name: str) -> Optional[str]:
    normalized = name.lower().replace(" ", "_").replace("-", "_")
    return normalized if normalized in ITEM_DATA else None
def describe_items(items: List[Tuple[str, int, int]]) -> List[str]:
    lines = []
    for key, qty, value in items:
        item_name = ITEM_DATA[key]["name"]
        lines.append(f"{item_name} x{qty} • {currency(value)}")
    return lines

class CoinflipView(discord.ui.View):
    def __init__(self, manager: EconomyManager, challenger_id: int, target_id: int, amount: int):
        super().__init__(timeout=60)
        self.manager = manager
        self.challenger_id = challenger_id
        self.target_id = target_id
        self.amount = amount
        self.message: Optional[discord.Message] = None
    def _disable_controls(self) -> None:
        for child in self.children:
            child.disabled = True
    @discord.ui.button(label="Accept", style=discord.ButtonStyle.success)
    async def accept(self, interaction: discord.Interaction, _: discord.ui.Button) -> None:
        if interaction.user.id != self.target_id:
            await interaction.response.defer()
            return
        challenger_has = await self.manager.has_wallet(self.challenger_id, self.amount)
        target_has = await self.manager.has_wallet(self.target_id, self.amount)
        if not challenger_has or not target_has:
            self._disable_controls()
            missing = self.challenger_id if not challenger_has else self.target_id
            content = f"<@{missing}> does not have enough funds for the coinflip."
            await interaction.response.edit_message(content=content, view=self)
            await self.manager.save()
            return
        if not await self.manager.deduct_wallet(self.challenger_id, self.amount):
            self._disable_controls()
            content = f"<@{self.challenger_id}> no longer has enough funds for the coinflip."
            await interaction.response.edit_message(content=content, view=self)
            await self.manager.save()
            return
        if not await self.manager.deduct_wallet(self.target_id, self.amount):
            await self.manager.add_wallet(self.challenger_id, self.amount)
            self._disable_controls()
            content = f"<@{self.target_id}> no longer has enough funds for the coinflip."
            await interaction.response.edit_message(content=content, view=self)
            await self.manager.save()
            return
        winner_id = random.choice([self.challenger_id, self.target_id])
        await self.manager.add_wallet(winner_id, self.amount * 2)
        self._disable_controls()
        content = (
            f"<@{self.target_id}> accepted the coinflip from <@{self.challenger_id}>. "
            f"<@{winner_id}> wins {currency(self.amount)}."
        )
        await interaction.response.edit_message(content=content, view=self)
        await self.manager.save()
    @discord.ui.button(label="Decline", style=discord.ButtonStyle.secondary)
    async def decline(self, interaction: discord.Interaction, _: discord.ui.Button) -> None:
        if interaction.user.id != self.target_id:
            await interaction.response.defer()
            return
        self.disable_all_items()
        content = f"<@{self.target_id}> declined the coinflip from <@{self.challenger_id}>."
        await interaction.response.edit_message(content=content, view=self)
    async def on_timeout(self) -> None:
        self.disable_all_items()
        if self.message:
            await self.message.edit(content="Coinflip request expired.", view=self)

class Economy(commands.Cog):
    def __init__(self, bot: commands.Bot, manager: EconomyManager):
        self.bot = bot
        self.manager = manager
    async def cog_load(self) -> None:
        await self.manager.load()
    @app_commands.guild_only()
    @app_commands.command(name="balance", description="Check wallet and bank balances")
    async def balance(self, interaction: discord.Interaction, user: Optional[discord.User] = None) -> None:
        target = user or interaction.user
        await self.manager.ensure_user(target.id)
        wallet, bank = await self.manager.get_balances(target.id)
        embed = embedbuildthing("Balance")
        if hasattr(target, "display_avatar"):
            embed.set_author(name=str(target), icon_url=target.display_avatar.url)
        else:
            embed.set_author(name=str(target))
        embed.add_field(name="Wallet", value=currency(wallet), inline=False)
        embed.add_field(name="Bank", value=currency(bank), inline=False)
        await interaction.response.send_message(embed=embed)
        await self.manager.save()
    @app_commands.guild_only()
    @app_commands.command(name="deposit", description="Deposit money into your bank")
    async def deposit(self, interaction: discord.Interaction, amount: Optional[int] = None) -> None:
        if amount is not None and amount <= 0:
            embed = embedbuildthing("Invalid Amount", "Enter a positive amount to deposit.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        deposited = await self.manager.deposit(interaction.user.id, amount)
        if deposited <= 0:
            embed = embedbuildthing("Deposit Failed", "No funds available in your wallet.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        embed = embedbuildthing("Deposit Successful", f"Deposited {currency(deposited)} into your bank.", color=discord.Color.green())
        await interaction.response.send_message(embed=embed)
        await self.manager.save()
    @app_commands.guild_only()
    @app_commands.command(name="withdraw", description="Withdraw money from your bank")
    async def withdraw(self, interaction: discord.Interaction, amount: Optional[int] = None) -> None:
        if amount is not None and amount <= 0:
            embed = embedbuildthing("Invalid Amount", "Enter a positive amount to withdraw.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        withdrawn = await self.manager.withdraw(interaction.user.id, amount)
        if withdrawn <= 0:
            embed = embedbuildthing("Withdraw Failed", "No funds available in your bank.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        embed = embedbuildthing("Withdraw Successful", f"Withdrew {currency(withdrawn)} into your wallet.", color=discord.Color.green())
        await interaction.response.send_message(embed=embed)
        await self.manager.save()
    @app_commands.guild_only()
    @app_commands.command(name="leaderboard", description="Show the richest players")
    async def leaderboard(self, interaction: discord.Interaction) -> None:
        standings = await self.manager.leaderboard()
        if not standings:
            embed = embedbuildthing("Leaderboard", "No players found.")
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        lines = []
        top_user_obj: Optional[discord.abc.User] = None
        for index, (user_id, wallet, bank, total) in enumerate(standings, start=1):
            user_obj = self.bot.get_user(user_id)
            if user_obj is None:
                try:
                    user_obj = await self.bot.fetch_user(user_id)
                except discord.HTTPException:
                    user_obj = None
            mention = user_obj.mention if hasattr(user_obj, "mention") else f"<@{user_id}>"
            if index == 1 and user_obj is not None:
                top_user_obj = user_obj
            lines.append(f"{index}. {mention} • Wallet {currency(wallet)} • Bank {currency(bank)} • Total {currency(total)}")
        embed = embedbuildthing("Leaderboard", "\n".join(lines))
        if top_user_obj and hasattr(top_user_obj, "display_avatar"):
            embed.set_thumbnail(url=top_user_obj.display_avatar.url)
        await interaction.response.send_message(embed=embed)
        await self.manager.save()
    @app_commands.guild_only()
    @app_commands.command(name="inventory", description="Show your inventory")
    async def inventory(self, interaction: discord.Interaction) -> None:
        await self.manager.ensure_user(interaction.user.id)
        inventory = await self.manager.get_inventory(interaction.user.id)
        if not inventory:
            embed = embedbuildthing("Inventory", "You have no items.")
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        lines = []
        for key, amount in inventory.items():
            item_name = ITEM_DATA[key]["name"]
            lines.append(f"{item_name} x{amount}")
        embed = embedbuildthing("Inventory", "\n".join(lines))
        await interaction.response.send_message(embed=embed)
        await self.manager.save()
    @app_commands.guild_only()
    @app_commands.command(name="sell", description="Sell items from your inventory")
    @app_commands.describe(item="Item to sell", amount="Quantity to sell")
    async def sell(self, interaction: discord.Interaction, item: Optional[str] = None, amount: Optional[int] = None) -> None:
        if amount is not None and amount <= 0:
            embed = embedbuildthing("Invalid Amount", "Enter a positive amount to sell.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        item_key = None
        if item:
            resolved = resolve_item_key(item)
            if not resolved:
                embed = embedbuildthing("Invalid Item", "That item does not exist.", color=discord.Color.red())
                await interaction.response.send_message(embed=embed)
                await self.manager.save()
                return
            item_key = resolved
        details, total_value = await self.manager.sell_items(interaction.user.id, item_key, amount)
        if not details:
            embed = embedbuildthing("Nothing Sold", "You have no items to sell.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        lines = describe_items(details)
        embed = embedbuildthing("Items Sold", "\n".join(lines), color=discord.Color.green())
        embed.add_field(name="Total Earned", value=currency(total_value), inline=False)
        await interaction.response.send_message(embed=embed)
        await self.manager.save()
    @app_commands.guild_only()
    @app_commands.command(name="beg", description="Beg for money")
    async def beg(self, interaction: discord.Interaction) -> None:
        roll = random.random()
        if roll < 0.33:
            description = "You received nothing."
        elif roll < 0.66:
            amount = random.randint(3, 5)
            await self.manager.add_wallet(interaction.user.id, amount)
            description = f"You received {currency(amount)}."
        elif roll < 0.81:
            amount = random.randint(9, 16)
            await self.manager.add_wallet(interaction.user.id, amount)
            description = f"You received {currency(amount)}."
        elif roll < 0.86:
            await self.manager.add_item(interaction.user.id, "golden_potato")
            description = "You found a Golden Potato."
        elif roll < 0.87:
            await self.manager.add_bank(interaction.user.id, 120)
            description = "You found a wallet with $120 and placed it in your bank."
        else:
            description = "You received nothing."
        embed = embedbuildthing("Begging Results", description)
        await interaction.response.send_message(embed=embed)
        await self.manager.save()
    @app_commands.guild_only()
    @app_commands.command(name="fish", description="Go fishing")
    async def fish(self, interaction: discord.Interaction) -> None:
        roll = random.random()
        catch = None
        if roll < 0.20:
            catch = "rainbow_trout"
        elif roll < 0.35:
            catch = "bass"
        elif roll < 0.50:
            catch = "sunfish"
        elif roll < 0.60:
            catch = "spearfish"
        elif roll < 0.70:
            catch = "voltfish"
        elif roll < 0.701:
            catch = "angel_o8"
        if catch:
            await self.manager.add_item(interaction.user.id, catch)
            item_name = ITEM_DATA[catch]["name"]
            embed = embedbuildthing("Fishing Results", f"You caught a {item_name}.")
        else:
            embed = embedbuildthing("Fishing Results", "You caught nothing.")
        await interaction.response.send_message(embed=embed)
        await self.manager.save()
    @app_commands.guild_only()
    @app_commands.command(name="gamble", description="Gamble your money")
    async def gamble(self, interaction: discord.Interaction, amount: int) -> None:
        if amount <= 0:
            embed = embedbuildthing("Invalid Amount", "Enter a positive amount to gamble.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        if not await self.manager.has_wallet(interaction.user.id, amount):
            embed = embedbuildthing("Insufficient Funds", "You do not have enough money in your wallet.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        if not await self.manager.deduct_wallet(interaction.user.id, amount):
            embed = embedbuildthing("Insufficient Funds", "You do not have enough money in your wallet.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        roll = random.random()
        if roll < 0.70:
            returned = amount // 2
            if returned > 0:
                await self.manager.add_wallet(interaction.user.id, returned)
            result = f"You halved your bet and received {currency(returned)}."
        elif roll < 0.80:
            result = "You lost everything you gambled."
        else:
            winnings = amount * 2
            await self.manager.add_wallet(interaction.user.id, winnings)
            result = f"You doubled your bet and won {currency(winnings)}."
        embed = embedbuildthing("Gamble Results", result)
        await interaction.response.send_message(embed=embed)
        await self.manager.save()
    @app_commands.guild_only()
    @app_commands.command(name="donate", description="Donate money to another user")
    @app_commands.describe(user="Recipient", amount="Amount to donate")
    async def donate(self, interaction: discord.Interaction, user: discord.Member, amount: int) -> None:
        if user.id == interaction.user.id:
            embed = embedbuildthing("Invalid Recipient", "You cannot donate to yourself.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        if amount <= 0:
            embed = embedbuildthing("Invalid Amount", "Enter a positive amount to donate.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        if not await self.manager.has_wallet(interaction.user.id, amount):
            embed = embedbuildthing("Insufficient Funds", "You do not have enough money in your wallet.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        if not await self.manager.deduct_wallet(interaction.user.id, amount):
            embed = embedbuildthing("Insufficient Funds", "You do not have enough money in your wallet.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        await self.manager.add_wallet(user.id, amount)
        embed = embedbuildthing("Donation Successful", f"Donated {currency(amount)} to {user.mention}.", color=discord.Color.green())
        await interaction.response.send_message(embed=embed)
        await self.manager.save()
    @app_commands.guild_only()
    @app_commands.command(name="givemoney", description="Give money to a user (admin only)")
    @app_commands.describe(user="User to receive money", amount="Amount to give")
    async def givemoney(self, interaction: discord.Interaction, user: discord.Member, amount: int) -> None:
        if not (interaction.user.guild_permissions.manage_messages and interaction.user.guild_permissions.ban_members):
            embed = embedbuildthing("Permission Denied", "You must have too many permissions to use this command.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        if amount <= 0:
            embed = embedbuildthing("Invalid Amount", "Enter a positive amount to give.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        await self.manager.add_wallet(user.id, amount)
        embed = embedbuildthing("Funds Granted", f"Gave {currency(amount)} to {user.mention}.", color=discord.Color.green())
        await interaction.response.send_message(embed=embed)
        await self.manager.save()
    @app_commands.guild_only()
    @app_commands.command(name="giveitem", description="Give an item to a user (admin only)")
    @app_commands.describe(user="User to receive the item")
    @app_commands.choices(item=[app_commands.Choice(name=data["name"], value=key) for key, data in ITEM_DATA.items()])
    async def giveitem(self, interaction: discord.Interaction, user: discord.Member, item: app_commands.Choice[str]) -> None:
        if not (interaction.user.guild_permissions.manage_messages and interaction.user.guild_permissions.ban_members):
            embed = embedbuildthing("Permission Denied", "You must have a whole lotta permissions to use this command.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        await self.manager.add_item(user.id, item.value)
        item_name = ITEM_DATA[item.value]["name"]
        embed = embedbuildthing("Item Granted", f"Gave {item_name} to {user.mention}.", color=discord.Color.green())
        await interaction.response.send_message(embed=embed)
        await self.manager.save()
    @app_commands.guild_only()
    @app_commands.command(name="coinflip", description="Coinflip another user")
    @app_commands.describe(user="Opponent", amount="Amount to wager")
    async def coinflip(self, interaction: discord.Interaction, user: discord.Member, amount: int) -> None:
        if user.id == interaction.user.id:
            embed = embedbuildthing("Invalid Opponent", "You cannot coinflip yourself.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        if amount <= 0:
            embed = embedbuildthing("Invalid Amount", "Enter a positive amount to wager.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        if not await self.manager.has_wallet(interaction.user.id, amount):
            embed = embedbuildthing("Insufficient Funds", "You do not have enough money in your wallet.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        await self.manager.ensure_user(user.id)
        if not await self.manager.has_wallet(user.id, amount):
            embed = embedbuildthing("Opponent Funds", f"{user.mention} does not have enough money to coinflip.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        view = CoinflipView(self.manager, interaction.user.id, user.id, amount)
        content = f"{interaction.user.mention} challenged {user.mention} to a coinflip for {currency(amount)}."
        await interaction.response.send_message(content=content, view=view)
        view.message = await interaction.original_response()
        await self.manager.save()
    @app_commands.guild_only()
    @app_commands.command(name="shop", description="Buy items from the shop")
    @app_commands.describe(item="Item to buy")
    @app_commands.choices(item=[app_commands.Choice(name=ITEM_DATA[key]["name"], value=key) for key in SHOP_ITEMS])
    async def shop(self, interaction: discord.Interaction, item: app_commands.Choice[str]) -> None:
        item_key = item.value
        item_data = ITEM_DATA[item_key]
        price = item_data["price"]
        
        if not await self.manager.has_wallet(interaction.user.id, price):
            embed = embedbuildthing("Insufficient Funds", f"You need {currency(price)} to buy {item_data['name']}.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        
        if not await self.manager.deduct_wallet(interaction.user.id, price):
            embed = embedbuildthing("Insufficient Funds", f"You need {currency(price)} to buy {item_data['name']}.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        
        await self.manager.add_item(interaction.user.id, item_key)
        embed = embedbuildthing("Purchase Successful", f"Bought {item_data['name']} for {currency(price)}.", color=discord.Color.green())
        await interaction.response.send_message(embed=embed)
        await self.manager.save()
    @app_commands.guild_only()
    @app_commands.command(name="robbery", description="Rob a location")
    @app_commands.describe(location="Location to rob")
    @app_commands.choices(location=[
        app_commands.Choice(name="Gas Station", value="gas_station"),
        app_commands.Choice(name="House", value="house"),
        app_commands.Choice(name="Jewelry Store", value="jewelry_store"),
        app_commands.Choice(name="Government Laboratory", value="lab"),
    ])
    async def robbery(self, interaction: discord.Interaction, location: app_commands.Choice[str]) -> None:
        location_type = location.value
        inventory = await self.manager.get_inventory(interaction.user.id)
        
        robbery_configs = {
            "gas_station": {
                "name": "Gas Station",
                "required_items": [],
                "time": 30,
                "min_payout": 300,
                "max_payout": 700,
                "base_catch_chance": 0.20,
                "wallet_penalty": 0.60,
                "bank_penalty": 0.05,
                "seize_items": False,
            },
            "house": {
                "name": "House",
                "required_items": ["lockpick"],
                "time": 60,
                "min_payout": 2000,
                "max_payout": 3000,
                "base_catch_chance": 0.60,
                "wallet_penalty": 0.60,
                "bank_penalty": 0.05,
                "seize_items": True,
            },
            "jewelry_store": {
                "name": "Jewelry Store",
                "required_items": ["lockpick", "gun"],
                "time": 90,
                "min_payout": 10000,
                "max_payout": 16000,
                "base_catch_chance": 0.90,
                "wallet_penalty": 0.75,
                "bank_penalty": 0.10,
                "seize_items": True,
            },
            "lab": {
                "name": "Government Laboratory",
                "required_items": ["advanced_lockpick", "gun", "hacker_tool"],
                "time": 180,
                "min_payout": 200000,
                "max_payout": 400000,
                "base_catch_chance": 0.95,
                "wallet_penalty": 0.80,
                "bank_penalty": 0.15,
                "seize_items": True,
            },
        }
        
        config = robbery_configs[location_type]
        
        if not await self.manager.has_items(interaction.user.id, config["required_items"]):
            missing = [ITEM_DATA[item]["name"] for item in config["required_items"] if not inventory.get(item, 0)]
            embed = embedbuildthing("Missing Requirements", f"You need: {', '.join(missing)}", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        
        await interaction.response.defer()
        
        catch_chance = config["base_catch_chance"]
        has_mask = inventory.get("mask", 0) > 0
        has_lpb = inventory.get("license_plate_blocker", 0) > 0
        
        if location_type == "lab":
            if has_mask:
                catch_chance -= 0.05
            if has_lpb:
                catch_chance -= 0.03
        else:
            if has_mask:
                catch_chance -= 0.10
            if has_lpb:
                catch_chance -= 0.25
        
        catch_chance = max(0.0, min(1.0, catch_chance))
        
        embed = embedbuildthing("Robbery in Progress", f"Robbing {config['name']}... This will take {config['time']} seconds.", color=discord.Color.orange())
        embed.add_field(name="Catch Chance", value=f"{catch_chance * 100:.1f}%", inline=False)
        message = await interaction.followup.send(embed=embed)
        
        await asyncio.sleep(config["time"])
        
        wallet, bank = await self.manager.get_balances(interaction.user.id)
        total_wallet = wallet
        total_bank = bank
        
        caught = random.random() < catch_chance
        
        if caught:
            wallet_penalty = int(total_wallet * config["wallet_penalty"])
            bank_penalty = int(total_bank * config["bank_penalty"])
            
            await self.manager.deduct_wallet(interaction.user.id, wallet_penalty)
            new_bank = max(0, total_bank - bank_penalty)
            async with self.manager.lock:
                user = self.manager._ensure_user(interaction.user.id)
                user["bank"] = new_bank
            
            seized_items = {}
            if config["seize_items"]:
                seized_items = await self.manager.seize_all_items(interaction.user.id)
            
            description = "You were caught! The robbery failed."
            description += f"\nWallet penalty: {currency(wallet_penalty)}"
            description += f"\nBank penalty: {currency(bank_penalty)}"
            if seized_items:
                item_names = [ITEM_DATA[key]["name"] for key in seized_items.keys()]
                description += f"\nSeized items: {', '.join(item_names)}"
            
            embed = embedbuildthing("Robbery Failed", description, color=discord.Color.red())
        else:
            payout = random.randint(config["min_payout"], config["max_payout"])
            await self.manager.add_wallet(interaction.user.id, payout)
            embed = embedbuildthing("Robbery Successful", f"You successfully robbed {config['name']} and got {currency(payout)}!", color=discord.Color.green())
        
        await message.edit(embed=embed)
        await self.manager.save()
    @app_commands.guild_only()
    @app_commands.command(name="mug", description="Mug another user")
    @app_commands.describe(user="User to mug", amount="Amount to steal from wallet")
    async def mug(self, interaction: discord.Interaction, user: discord.Member, amount: int) -> None:
        if user.id == interaction.user.id:
            embed = embedbuildthing("Invalid Target", "You cannot mug yourself.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        
        if amount <= 0:
            embed = embedbuildthing("Invalid Amount", "Enter a positive amount to mug.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        
        await self.manager.ensure_user(user.id)
        wallet, _ = await self.manager.get_balances(user.id)
        
        if wallet < amount:
            embed = embedbuildthing("Insufficient Funds", f"{user.mention} only has {currency(wallet)} in their wallet.", color=discord.Color.red())
            await interaction.response.send_message(embed=embed)
            await self.manager.save()
            return
        
        inventory = await self.manager.get_inventory(interaction.user.id)
        has_mask = inventory.get("mask", 0) > 0
        has_lpb = inventory.get("license_plate_blocker", 0) > 0
        
        catch_chance = 0.50
        catch_chance += (amount // 20) * 0.03
        
        if has_mask:
            catch_chance /= 2
        if has_lpb:
            catch_chance /= 2
        
        catch_chance = max(0.0, min(1.0, catch_chance))
        
        caught = random.random() < catch_chance
        
        if caught:
            embed = embedbuildthing("Mugging Failed", f"You were caught trying to mug {user.mention}!", color=discord.Color.red())
        else:
            if await self.manager.deduct_wallet(user.id, amount):
                await self.manager.add_wallet(interaction.user.id, amount)
                embed = embedbuildthing("Mugging Successful", f"You successfully mugged {user.mention} and stole {currency(amount)}!", color=discord.Color.green())
            else:
                embed = embedbuildthing("Mugging Failed", f"Failed to steal from {user.mention}.", color=discord.Color.red())
        
        await interaction.response.send_message(embed=embed)
        await self.manager.save()

def current_time() -> datetime:
    return datetime.now(timezone.utc)
def load_data() -> None:
    """Load moderation data from JSON file"""
    global case_counter, user_cases, user_warns
    
    if not DATA_FILE.exists():
        return
    
    try:
        with open(DATA_FILE, 'r') as f:
            data = json.load(f)
        
        case_counter = data.get('case_counter', 1)
        
        raw_cases = data.get('user_cases', {})
        user_cases = defaultdict(list)
        for user_id, cases in raw_cases.items():
            for case in cases:
                case['timestamp'] = datetime.fromisoformat(case['timestamp'])
                user_cases[int(user_id)].append(case)
        
        raw_warns = data.get('user_warns', {})
        user_warns = defaultdict(list)
        for user_id, warns in raw_warns.items():
            for warn in warns:
                warn['issued_at'] = datetime.fromisoformat(warn['issued_at'])
                if warn['expires_at']:
                    warn['expires_at'] = datetime.fromisoformat(warn['expires_at'])
                user_warns[int(user_id)].append(warn)
        
        print(f"Loaded {len(user_cases)} users with cases and {len(user_warns)} users with warnings")
    except Exception as e:
        print(f"Error loading data: {e}")
def save_data() -> None:
    """Save moderation data to JSON file"""
    try:
        serializable_cases = {}
        for user_id, cases in user_cases.items():
            serializable_cases[str(user_id)] = [
                {
                    **case,
                    'timestamp': case['timestamp'].isoformat()
                }
                for case in cases
            ]
        
        serializable_warns = {}
        for user_id, warns in user_warns.items():
            serializable_warns[str(user_id)] = [
                {
                    **warn,
                    'issued_at': warn['issued_at'].isoformat(),
                    'expires_at': warn['expires_at'].isoformat() if warn['expires_at'] else None
                }
                for warn in warns
            ]
        
        data = {
            'case_counter': case_counter,
            'user_cases': serializable_cases,
            'user_warns': serializable_warns
        }
        
        with open(DATA_FILE, 'w') as f:
            json.dump(data, f, indent=2)
    except Exception as e:
        print(f"Error saving data: {e}")
def embedbuildthing(title: str, description: Optional[str] = None, *, color: discord.Color = discord.Color.blurple()) -> discord.Embed:
    embed = discord.Embed(title=title, description=description, color=color, timestamp=discord.utils.utcnow())
    return embed
def respond_embed(action: str, interaction: discord.Interaction, target: discord.abc.User, reason: Optional[str], extra: Optional[str] = None, *, color: discord.Color = discord.Color.blurple()) -> discord.Embed:
    reason_value = reason if reason else "No reason provided"
    embed = embedbuildthing(action, color=color)
    embed.add_field(name="Target", value=f"{target.mention} ({target.id})", inline=False)
    embed.add_field(name="Moderator", value=f"{interaction.user.mention} ({interaction.user.id})", inline=False)
    embed.add_field(name="Reason", value=reason_value, inline=False)
    if extra:
        embed.add_field(name="Details", value=extra, inline=False)
    return embed
def user_dm_embed(action: str, guild: discord.Guild, reason: Optional[str], extra: Optional[str] = None, *, color: discord.Color = discord.Color.blurple()) -> discord.Embed:
    reason_value = reason if reason else "No reason provided"
    embed = embedbuildthing(f"Moderation Action: {action}", color=color)
    embed.add_field(name="Server", value=guild.name, inline=False)
    embed.add_field(name="Reason", value=reason_value, inline=False)
    if extra:
        embed.add_field(name="Details", value=extra, inline=False)
    return embed
async def notify_user(user: discord.abc.User, action: str, guild: discord.Guild, reason: Optional[str], extra: Optional[str] = None, color: discord.Color = discord.Color.blurple()) -> bool:
    """Send a DM to the user about the moderation action. Returns True if successful."""
    try:
        embed = user_dm_embed(action, guild, reason, extra, color=color)
        await user.send(embed=embed)
        return True
    except (discord.Forbidden, discord.HTTPException):
        return False
def record_case(interaction: discord.Interaction, target: discord.abc.User, action: str, reason: Optional[str], extra: Optional[str] = None) -> dict:
    global case_counter
    entry = {
        "case_id": case_counter,
        "action": action,
        "moderator_id": interaction.user.id,
        "timestamp": current_time(),
        "reason": reason,
        "extra": extra,
    }
    user_cases[target.id].append(entry)
    case_counter += 1
    save_data()
    return entry
async def send_interaction_embed(interaction: discord.Interaction, embed: discord.Embed) -> None:
    if interaction.response.is_done():
        await interaction.followup.send(embed=embed, ephemeral=True)
    else:
        await interaction.response.send_message(embed=embed, ephemeral=True)
async def schedule_unban(guild: discord.Guild, user_id: int, hours: float) -> None:
    try:
        await asyncio.sleep(hours * 3600)
        await guild.unban(discord.Object(id=user_id), reason="Temporary ban expired")
    except (discord.NotFound, discord.Forbidden):
        return

@bot.event
async def setup_hook():
    await bot.add_cog(Economy(bot, economy_manager))


@bot.event
async def on_ready():
    try:
        load_data()
        await economy_manager.load()
        print("Logged in")
        synced = await bot.tree.sync()
        print(f"Locked in and synced {len(synced)} command{'s' if len(synced) != 1 else ''}")
    except Exception as e:
        print(f"Error syncing commands: {e}")


@app_commands.guild_only()
@app_commands.default_permissions(moderate_members=True)
@app_commands.describe(member="Member to timeout", minutes="Duration in minutes", reason="Reason for the timeout")
@bot.tree.command(name="timeout")
async def timeout_command(interaction: discord.Interaction, member: discord.Member, minutes: app_commands.Range[float, 1, 10080], reason: Optional[str] = None):
    duration = timedelta(minutes=minutes)
    await member.timeout(duration=duration, reason=reason or f"Timeout issued by {interaction.user}")
    extra = f"Duration: {minutes:.2f} minutes"
    record_case(interaction, member, "Timeout", reason, extra)
    
    dm_sent = await notify_user(member, "Timeout", interaction.guild, reason, extra, color=discord.Color.orange())
    
    embed = respond_embed("Timeout Applied", interaction, member, reason, extra)
    if not dm_sent:
        embed.set_footer(text="Could not DM user. DMs most likely off.")
    await send_interaction_embed(interaction, embed)


@app_commands.guild_only()
@app_commands.default_permissions(moderate_members=True)
@app_commands.describe(member="Member to remove from timeout", reason="Reason for removal")
@bot.tree.command(name="untimeout", description="Remove timeout from a member.")
async def untimeout_command(interaction: discord.Interaction, member: discord.Member, reason: Optional[str] = None):
    await member.timeout(duration=None, reason=reason or f"Timeout removed by {interaction.user}")
    record_case(interaction, member, "Timeout Cleared", reason)
    
    dm_sent = await notify_user(member, "Timeout Cleared", interaction.guild, reason, color=discord.Color.green())
    
    embed = respond_embed("Timeout Cleared", interaction, member, reason)
    if not dm_sent:
        embed.set_footer(text="Could not DM user. DMs most likely off.")
    await send_interaction_embed(interaction, embed)


@app_commands.guild_only()
@app_commands.default_permissions(moderate_members=True)
@app_commands.describe(member="Member to warn", reason="Reason for the warning", expiration="Expiration date (YYYY-MM-DD). Leave blank for permanent warning.")
@bot.tree.command(name="warn", description="Warn a user.")
async def warn_command(interaction: discord.Interaction, member: discord.Member, reason: str, expiration: Optional[str] = None):
    expires_at: Optional[datetime] = None
    if expiration and expiration.lower() != "inf":
        try:
            expires_at = datetime.fromisoformat(expiration)
            if expires_at.tzinfo is None:
                expires_at = expires_at.replace(tzinfo=timezone.utc)
        except ValueError:
            embed = embedbuildthing("Invalid Expiration", "Expiration date (YYYY-MM-DD). Leave blank for permanent warning.", color=discord.Color.red())
            await send_interaction_embed(interaction, embed)
            return
    entry = record_case(interaction, member, "Warning", reason, f"Expires: {expires_at.isoformat()}" if expires_at else "Expires: Never")
    warn_entry = {
        "case_id": entry["case_id"],
        "reason": reason,
        "expires_at": expires_at,
        "issued_at": entry["timestamp"],
        "moderator_id": interaction.user.id,
    }
    user_warns[member.id].append(warn_entry)
    save_data()
    extra = f"Expires: {expires_at.isoformat()}" if expires_at else "Expires: Never"
    dm_sent = await notify_user(member, "Warning", interaction.guild, reason, extra, color=discord.Color.yellow())
    
    embed = respond_embed("Warning Issued", interaction, member, reason, extra)
    if not dm_sent:
        embed.set_footer(text="Could not DM user. DMs most likely off.")
    await send_interaction_embed(interaction, embed)


@app_commands.guild_only()
@app_commands.default_permissions(moderate_members=True)
@app_commands.describe(member="Member whose warning to clear", warn_number="Warning number to clear", reason="Reason for clearing")
@bot.tree.command(name="clearwarn", description="Clear a user's warn(s).")
async def clearwarn_command(interaction: discord.Interaction, member: discord.Member, warn_number: app_commands.Range[int, 1, 100], reason: Optional[str] = None):
    warns = user_warns.get(member.id, [])
    if warn_number > len(warns):
        embed = embedbuildthing("Warning Not Found", "Specify a valid warning number.", color=discord.Color.red())
        await send_interaction_embed(interaction, embed)
        return
    cleared = warns.pop(warn_number - 1)
    user_warns[member.id] = warns
    record_case(interaction, member, "Warning Cleared", reason, f"Cleared Case #{cleared['case_id']}")
    save_data()
    extra = f"Cleared warning #{warn_number} (Case #{cleared['case_id']})"
    
    dm_sent = await notify_user(member, "Warning Cleared", interaction.guild, reason, extra, color=discord.Color.green())
    
    embed = respond_embed("Warning Cleared", interaction, member, reason, extra)
    if not dm_sent:
        embed.set_footer(text="Could not DM user. DMs most likely off.")
    await send_interaction_embed(interaction, embed)


@app_commands.guild_only()
@app_commands.default_permissions(moderate_members=True)
@app_commands.describe(member="Member to review warnings for")
@bot.tree.command(name="listwarn", description="List a user's warnings.")
async def listwarn_command(interaction: discord.Interaction, member: discord.Member):
    warns = user_warns.get(member.id, [])
    if not warns:
        embed = embedbuildthing("No Warnings", f"{member.mention} has no recorded warnings.")
        await send_interaction_embed(interaction, embed)
        return
    lines = []
    for idx, warn in enumerate(warns, start=1):
        expires = warn["expires_at"].isoformat() if warn["expires_at"] else "Never"
        timestamp = discord.utils.format_dt(warn["issued_at"], style="R")
        lines.append(f"**{idx}.** Case #{warn['case_id']} • {timestamp}\nReason: {warn['reason']}\nExpires: {expires}")
    embed = embedbuildthing("Warnings", "\n\n".join(lines))
    await send_interaction_embed(interaction, embed)


@app_commands.guild_only()
@app_commands.default_permissions(moderate_members=True)
@app_commands.describe(user="User to review cases for")
@bot.tree.command(name="cases", description="Review a members case log.")
async def cases_command(interaction: discord.Interaction, user: discord.User):
    cases = user_cases.get(user.id, [])
    if not cases:
        embed = embedbuildthing("No Cases", f"{user.mention} has no recorded cases.")
        await send_interaction_embed(interaction, embed)
        return
    lines = []
    for entry in cases[-25:][::-1]:
        timestamp = discord.utils.format_dt(entry["timestamp"], style="R")
        reason = entry["reason"] if entry["reason"] else "No reason provided"
        details = f"Details: {entry['extra']}" if entry["extra"] else ""
        lines.append(f"**Case #{entry['case_id']}** • {entry['action']} • {timestamp}\nReason: {reason}{'\n' + details if details else ''}")
    embed = embedbuildthing("Case Log", "\n\n".join(lines))
    await send_interaction_embed(interaction, embed)


@app_commands.guild_only()
@app_commands.default_permissions(kick_members=True)
@app_commands.describe(member="Member to kick", reason="Reason for kick")
@bot.tree.command(name="kick", description="Kick a member.")
async def kick_command(interaction: discord.Interaction, member: discord.Member, reason: Optional[str] = None):
    dm_sent = await notify_user(member, "Kick", interaction.guild, reason, color=discord.Color.red())
    
    await member.kick(reason=reason or f"Kicked by {interaction.user}")
    record_case(interaction, member, "Kick", reason)
    embed = respond_embed("Member Kicked", interaction, member, reason)
    if not dm_sent:
        embed.set_footer(text="Could not DM user. DMs most likely off.")
    await send_interaction_embed(interaction, embed)


@app_commands.guild_only()
@app_commands.default_permissions(ban_members=True)
@app_commands.describe(member="Member to temporarily ban", hours="Duration in hours", reason="Reason for the ban")
@bot.tree.command(name="tempban", description="Temporarily ban a member.")
async def tempban_command(interaction: discord.Interaction, member: discord.Member, hours: app_commands.Range[float, 1, 168], reason: Optional[str] = None):
    guild = interaction.guild
    if guild is None:
        return
    task = tempban_tasks.pop(member.id, None)
    if task and not task.done():
        task.cancel()
    
    extra = f"Duration: {hours:.2f} hours"
    
    dm_sent = await notify_user(member, "Temporary Ban", interaction.guild, reason, extra, color=discord.Color.red())
    
    await guild.ban(member, reason=reason or f"Tempban by {interaction.user}")
    record_case(interaction, member, "Temporary Ban", reason, extra)
    tempban_tasks[member.id] = asyncio.create_task(schedule_unban(guild, member.id, hours))
    embed = respond_embed("Temporary Ban Issued", interaction, member, reason, extra)
    if not dm_sent:
        embed.set_footer(text="Could not DM user. DMs most likely off.")
    await send_interaction_embed(interaction, embed)


@app_commands.guild_only()
@app_commands.default_permissions(ban_members=True)
@app_commands.describe(member="Member to permanently ban", reason="Reason for the ban")
@bot.tree.command(name="permban", description="Permanently ban a member.")
async def permban_command(interaction: discord.Interaction, member: discord.Member, reason: Optional[str] = None):
    guild = interaction.guild
    if guild is None:
        return
    task = tempban_tasks.pop(member.id, None)
    if task and not task.done():
        task.cancel()
    
    dm_sent = await notify_user(member, "Permanent Ban", interaction.guild, reason, color=discord.Color.dark_red())
    
    await guild.ban(member, reason=reason or f"Permban by {interaction.user}")
    record_case(interaction, member, "Permanent Ban", reason)
    embed = respond_embed("Permanent Ban Issued", interaction, member, reason)
    if not dm_sent:
        embed.set_footer(text="Could not DM user. DMs most likely off.")
    await send_interaction_embed(interaction, embed)


@app_commands.guild_only()
@app_commands.default_permissions(manage_messages=True)
@app_commands.describe(member="Member whose messages to purge", message_count="Number of recent messages to check", reason="Reason for purge")
@bot.tree.command(name="purgeuser", description="Purge a users messages.")
async def purgeuser_command(interaction: discord.Interaction, member: discord.Member, message_count: app_commands.Range[int, 1, 500], reason: Optional[str] = None):
    channel = interaction.channel
    if not isinstance(channel, discord.TextChannel):
        embed = embedbuildthing("Unsupported Channel", "This command can only be used in text channels.", color=discord.Color.red())
        await send_interaction_embed(interaction, embed)
        return
    await interaction.response.defer(ephemeral=True)
    deleted = await channel.purge(limit=message_count, check=lambda msg: msg.author.id == member.id)
    details = f"Deleted {len(deleted)} messages in {channel.mention}"
    record_case(interaction, member, "Messages Purged", reason, f"Channel: {channel.mention}; Deleted {len(deleted)} messages")
    
    dm_sent = await notify_user(member, "Messages Purged", interaction.guild, reason, details, color=discord.Color.orange())
    
    embed = respond_embed("Messages Purged", interaction, member, reason, details)
    if not dm_sent:
        embed.set_footer(text="Could not DM user. DMs most likely off.")
    await interaction.followup.send(embed=embed, ephemeral=True)


bot.run("MTI3NDQ2NDkyODAxMDQ3MzQ3NA.GpJJNk.W8CDqYC1q-R_RyoNsAAVcwbTgvFsrhYr_GHjAc")